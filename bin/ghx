#!/usr/bin/env bash
set -euo pipefail

# ghxgit - GitHub eXperience CLI
# Search and jump to GitHub PRs, issues, branches, commits
# Manage Git workflow with enhanced branch and push helpers
# 
# Usage: ghx <command> [options]

VERSION="0.2.0"
VERBOSE=${VERBOSE:-0}

log_verbose() {
    if [[ "$VERBOSE" -eq 1 ]]; then
        echo "[DEBUG] $*" >&2
    fi
}

log_error() {
    echo "Error: $*" >&2
}

log_info() {
    echo "Info: $*" >&2
}

show_help() {
    cat <<EOF
ghx - GitHub Experience CLI Tool

USAGE
    ghx <command> [options]
    ghx --help
    ghx --version

COMMANDS
    jump <query>        Search and jump to a PR, issue, branch, or commit
    branch              Show current branch
    branch list         List all branches in the repository
    branch switch <name> Switch to a branch (with fuzzy search)
    branch delete <name> Delete a local branch (with confirmation)
    branch create <name> Create a new branch
    push                Smart git push with options
    status              Show git status
    log                 Show recent commits
    pull                Pull latest changes with rebase option
    sync                Fetch and pull latest changes

GLOBAL OPTIONS
    --verbose (-v)      Show debug output
    --help              Show this help message
    --version           Show version

EXAMPLES
    # Jump to PR/issue/branch/commit
    ghx jump OPS-123
    ghx jump "increase timeout" --open
    ghx jump OPS-123 --checkout

    # Branch management
    ghx branch list
    ghx branch switch main
    ghx branch create feature/new-feature
    ghx branch delete old-feature

    # Git workflow
    ghx push
    ghx push -u origin
    ghx push --force-with-lease
    ghx status
    ghx log
    ghx pull
    ghx pull --rebase
    ghx sync

JUMP OPTIONS (for 'ghx jump')
    --open              Open the best match in your browser
    --checkout          Checkout the matched PR/branch locally
    --type <type>       Limit search to: pr, issue, branch, commit
    --verbose (-v)      Show debug output

PUSH OPTIONS (for 'ghx push')
    --force             Force push (not recommended)
    --force-with-lease  Force push safely
    -u                  Set upstream
    --no-verify         Skip pre-push hooks
    <branch>            Specify branch (default: current)

BRANCH SEARCH
    When using 'ghx branch switch', you can:
    - Type a partial branch name for fuzzy matching
    - Press ENTER to select the highlighted branch
    - Type more to filter results

SEARCH ORDER (for 'ghx jump')
    1. Pull Requests in current repo
    2. Issues in current repo
    3. Branches in current repo
    4. Commits in current repo

REQUIREMENTS
    - gh (GitHub CLI) - https://github.com/cli/cli
    - jq (JSON processor)
    - git

EOF
}

show_version() {
    echo "ghxgit v$VERSION"
}

# Get the GitHub repo owner and name from git remote
get_repo_info() {
    local remote_url
    remote_url=$(git config --get remote.origin.url 2>/dev/null || echo "")
    
    if [[ -z "$remote_url" ]]; then
        log_error "Not a git repository or no origin remote found"
        return 1
    fi
    
    # Extract owner/repo from various git URL formats
    if [[ "$remote_url" =~ ^https://github.com/([^/]+)/([^/]+)(\.git)?$ ]]; then
        echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}" | sed 's/.git$//'
    elif [[ "$remote_url" =~ ^git@github.com:([^/]+)/([^/]+)(\.git)?$ ]]; then
        echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}" | sed 's/.git$//'
    else
        log_error "Could not parse GitHub repository from remote URL: $remote_url"
        return 1
    fi
}

# Search for PRs matching the query
search_prs() {
    local repo="$1"
    local query="$2"
    
    log_verbose "Searching PRs in $repo for: $query"
    
    # Search by PR number or title/body
    if [[ "$query" =~ ^[0-9]+$ ]]; then
        # Exact PR number
        gh pr view "$query" --repo "$repo" --json "number,title,url,headRefName,state" 2>/dev/null || return 1
    else
        # Search by title/body
        gh search prs --repo "$repo" "$query" --limit 1 --json "number,title,url,headRefName,state" --template '{{range .}}{{json .}}{{end}}' 2>/dev/null || return 1
    fi
}

# Search for issues matching the query
search_issues() {
    local repo="$1"
    local query="$2"
    
    log_verbose "Searching issues in $repo for: $query"
    
    # Search by issue number or title/body
    if [[ "$query" =~ ^[A-Z]+-[0-9]+$ ]]; then
        # Likely a Jira-style issue key
        gh search issues --repo "$repo" "$query" --limit 1 --json "number,title,url,state" --template '{{range .}}{{json .}}{{end}}' 2>/dev/null || return 1
    else
        # Search by title/body
        gh search issues --repo "$repo" "$query" --limit 1 --json "number,title,url,state" --template '{{range .}}{{json .}}{{end}}' 2>/dev/null || return 1
    fi
}

# Search for branches matching the query
search_branches() {
    local repo="$1"
    local query="$2"
    
    log_verbose "Searching branches in $repo for: $query"
    
    # List branches and search locally
    gh api "repos/$repo/branches" --paginate --jq '.[] | select(.name | contains("'"$query"'")) | {name: .name, url: "https://github.com/'"$repo"'/tree/\(.name)"}' 2>/dev/null | head -1
}

# Search for commits matching the query
search_commits() {
    local repo="$1"
    local query="$2"
    
    log_verbose "Searching commits in $repo for: $query"
    
    gh search commits --repo "$repo" "$query" --limit 1 --json "oid,message,url" --template '{{range .}}{{json .}}{{end}}' 2>/dev/null || return 1
}

# Main search function that tries all types in order
search_all() {
    local repo="$1"
    local query="$2"
    local search_type="${3:-}"
    
    local result=""
    local found_type=""
    
    # If specific type requested, only search that type
    if [[ -n "$search_type" ]]; then
        log_verbose "Searching only for type: $search_type"
        case "$search_type" in
            pr)
                result=$(search_prs "$repo" "$query" 2>/dev/null) && found_type="pr"
                ;;
            issue)
                result=$(search_issues "$repo" "$query" 2>/dev/null) && found_type="issue"
                ;;
            branch)
                result=$(search_branches "$repo" "$query" 2>/dev/null) && found_type="branch"
                ;;
            commit)
                result=$(search_commits "$repo" "$query" 2>/dev/null) && found_type="commit"
                ;;
            *)
                log_error "Unknown search type: $search_type"
                return 1
                ;;
        esac
    else
        # Default search order: PR -> Issue -> Branch -> Commit
        log_verbose "Searching in order: PR -> Issue -> Branch -> Commit"
        
        if result=$(search_prs "$repo" "$query" 2>/dev/null); then
            found_type="pr"
        elif result=$(search_issues "$repo" "$query" 2>/dev/null); then
            found_type="issue"
        elif result=$(search_branches "$repo" "$query" 2>/dev/null); then
            found_type="branch"
        elif result=$(search_commits "$repo" "$query" 2>/dev/null); then
            found_type="commit"
        fi
    fi
    
    if [[ -z "$result" ]]; then
        log_error "No matches found for query: $query"
        return 1
    fi
    
    echo "$result"
    echo "$found_type"
}

# Parse JSON result and extract info
extract_info() {
    local result="$1"
    local found_type="$2"
    
    case "$found_type" in
        pr)
            local number=$(echo "$result" | jq -r '.number')
            local title=$(echo "$result" | jq -r '.title')
            local url=$(echo "$result" | jq -r '.url')
            local branch=$(echo "$result" | jq -r '.headRefName')
            echo "$number" "$title" "$url" "$branch" "$found_type"
            ;;
        issue)
            local number=$(echo "$result" | jq -r '.number')
            local title=$(echo "$result" | jq -r '.title')
            local url=$(echo "$result" | jq -r '.url')
            echo "$number" "$title" "$url" "" "$found_type"
            ;;
        branch)
            local name=$(echo "$result" | jq -r '.name')
            local url=$(echo "$result" | jq -r '.url')
            echo "" "$name" "$url" "$name" "$found_type"
            ;;
        commit)
            local oid=$(echo "$result" | jq -r '.oid' | cut -c1-7)
            local message=$(echo "$result" | jq -r '.message' | head -1)
            local url=$(echo "$result" | jq -r '.url')
            echo "$oid" "$message" "$url" "" "$found_type"
            ;;
    esac
}

# Output result
print_result() {
    local number="$1"
    local title="$2"
    local url="$3"
    local branch_name="$4"
    local found_type="$5"
    
    printf "%-10s %s\n" "[$found_type]" "$title"
    if [[ -n "$number" ]]; then
        printf "%-10s %s\n" "Number:" "$number"
    fi
    if [[ -n "$branch_name" ]]; then
        printf "%-10s %s\n" "Branch:" "$branch_name"
    fi
    printf "%-10s %s\n" "URL:" "$url"
}

# Open URL in browser
open_url() {
    local url="$1"
    
    log_verbose "Opening URL: $url"
    
    if command -v xdg-open &>/dev/null; then
        xdg-open "$url"
    elif command -v open &>/dev/null; then
        open "$url"
    elif command -v wslview &>/dev/null; then
        wslview "$url"
    else
        log_error "Could not find a way to open browser. Please open manually: $url"
        return 1
    fi
}

# Checkout branch
checkout_branch() {
    local branch="$1"
    local found_type="$2"
    
    if [[ "$found_type" != "pr" && "$found_type" != "branch" ]]; then
        log_error "Can only checkout PR or branch, not $found_type"
        return 1
    fi
    
    if [[ -z "$branch" ]]; then
        log_error "No branch to checkout"
        return 1
    fi
    
    log_verbose "Checking out branch: $branch"
    git checkout "$branch" || git fetch origin "$branch:$branch" && git checkout "$branch"
}

# LIST BRANCHES - Show all branches in the repo
list_branches() {
    log_verbose "Listing branches"
    
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not a git repository"
        return 1
    fi
    
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    echo "Local branches:"
    echo "==============="
    git branch --list --format='%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short) %(if)%(objectname:short)%(then)(%(objectname:short))%(end)' | \
        awk -v current="$current_branch" '{
            if($0 ~ /^\*/) {
                printf "\033[32m%s\033[0m\n", $0  # Green for current
            } else {
                print $0
            }
        }'
    
    echo ""
    echo "Remote branches:"
    echo "================"
    git branch -r --list | grep -v HEAD | head -10 || echo "(none)"
}

# GET CURRENT BRANCH
get_current_branch() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        return 1
    fi
    git rev-parse --abbrev-ref HEAD
}

# SWITCH BRANCH - Switch to branch with fuzzy search
switch_branch() {
    local search_term="${1:-}"
    
    log_verbose "Switching branches"
    
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not a git repository"
        return 1
    fi
    
    # If no search term, list branches for user to choose
    if [[ -z "$search_term" ]]; then
        echo "Fetching branches..."
        git fetch --all --prune >/dev/null 2>&1 || true
        
        local branches
        branches=$(git branch -a --format='%(refname:short)' | grep -v HEAD | sort -u)
        
        if [[ -z "$branches" ]]; then
            log_error "No branches found"
            return 1
        fi
        
        # Try to use fzf if available, otherwise use grep
        local selected
        if command -v fzf &>/dev/null; then
            selected=$(echo "$branches" | fzf --preview 'git log -1 --date=short --format="Branch: %h %s (%cd)" {}')
        else
            echo "Available branches:"
            echo "$branches" | nl
            read -p "Select branch number: " -r selection
            selected=$(echo "$branches" | sed -n "${selection}p")
        fi
        
        if [[ -z "$selected" ]]; then
            log_error "No branch selected"
            return 1
        fi
        
        search_term="$selected"
    fi
    
    # Try exact match first
    if git branch -a | grep -q "^  $search_term$" || git branch -a | grep -q "^\* $search_term$"; then
        log_verbose "Switching to $search_term"
        git checkout "$search_term"
        return $?
    fi
    
    # Try matching in local branches
    local matching
    matching=$(git branch --list "*$search_term*" | sed 's/^[* ] //')
    
    if [[ -z "$matching" ]]; then
        # Try matching in remote branches
        matching=$(git branch -r --list "*$search_term*" | sed 's|origin/||' | sed 's/^ *//')
    fi
    
    if [[ -z "$matching" ]]; then
        log_error "No branches found matching: $search_term"
        echo "Did you mean:"
        git branch -a | head -5
        return 1
    fi
    
    # If multiple matches, show them
    local match_count
    match_count=$(echo "$matching" | wc -l)
    
    if [[ $match_count -gt 1 ]]; then
        echo "Multiple matches found:"
        echo "$matching" | nl
        
        if command -v fzf &>/dev/null; then
            local selected
            selected=$(echo "$matching" | fzf)
            matching="$selected"
        else
            read -p "Select branch number: " -r selection
            matching=$(echo "$matching" | sed -n "${selection}p")
        fi
    fi
    
    # Remove remote prefix if present
    matching=$(echo "$matching" | sed 's|origin/||')
    
    log_verbose "Checking out: $matching"
    git checkout "$matching"
}

# DELETE BRANCH
delete_branch() {
    local branch="$1"
    
    if [[ -z "$branch" ]]; then
        log_error "Branch name required"
        return 1
    fi
    
    local current_branch
    current_branch=$(get_current_branch)
    
    if [[ "$current_branch" == "$branch" ]]; then
        log_error "Cannot delete the currently checked out branch"
        return 1
    fi
    
    echo "Delete branch: $branch?"
    read -p "Are you sure? (y/N): " -r confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Cancelled"
        return 0
    fi
    
    if git branch -D "$branch"; then
        echo "âœ“ Deleted branch: $branch"
    else
        log_error "Failed to delete branch: $branch"
        return 1
    fi
}

# CREATE BRANCH
create_branch() {
    local branch="$1"
    local source="${2:-main}"
    
    if [[ -z "$branch" ]]; then
        log_error "Branch name required"
        return 1
    fi
    
    log_verbose "Creating branch: $branch from $source"
    
    if git rev-parse --verify "$source" >/dev/null 2>&1; then
        git checkout "$source"
        git pull origin "$source" 2>/dev/null || true
        git checkout -b "$branch"
        echo "âœ“ Created and switched to branch: $branch"
    else
        log_error "Source branch not found: $source"
        return 1
    fi
}

# GIT PUSH - Smart push helper
git_push() {
    local force_lease=0
    local force=0
    local set_upstream=0
    local no_verify=0
    local branch=""
    local push_args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force-with-lease)
                force_lease=1
                shift
                ;;
            --force)
                force=1
                shift
                ;;
            -u|--set-upstream)
                set_upstream=1
                shift
                ;;
            --no-verify)
                no_verify=1
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                branch="$1"
                shift
                ;;
        esac
    done
    
    # Validate branch
    if [[ -z "$branch" ]]; then
        branch=$(get_current_branch)
        log_verbose "Using current branch: $branch"
    fi
    
    # Build push arguments
    if [[ $force_lease -eq 1 ]]; then
        push_args+=("--force-with-lease")
    elif [[ $force -eq 1 ]]; then
        echo "âš ï¸  WARNING: Force push is dangerous!"
        read -p "Are you sure? (y/N): " -r confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo "Cancelled"
            return 0
        fi
        push_args+=("--force")
    fi
    
    if [[ $set_upstream -eq 1 ]]; then
        push_args+=("-u" "origin")
    fi
    
    if [[ $no_verify -eq 1 ]]; then
        push_args+=("--no-verify")
    fi
    
    push_args+=("$branch")
    
    echo "Pushing: git push ${push_args[*]}"
    git push "${push_args[@]}" || {
        local exit_code=$?
        if [[ $exit_code -eq 1 ]]; then
            echo ""
            echo "Push failed. Try:"
            echo "  ghx push -u origin $branch"
        fi
        return $exit_code
    }
}

# GIT PULL - Smart pull helper
git_pull() {
    local rebase=0
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --rebase)
                rebase=1
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ $rebase -eq 1 ]]; then
        echo "Pulling with rebase..."
        git pull --rebase
    else
        echo "Pulling..."
        git pull
    fi
}

# GIT SYNC - Fetch and pull
git_sync() {
    echo "Fetching all remotes..."
    git fetch --all --prune
    
    echo "Pulling latest changes..."
    git pull
}

# GIT STATUS - Show status
git_status() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not a git repository"
        return 1
    fi
    
    local branch
    branch=$(get_current_branch)
    
    echo "Branch: $branch"
    echo "Status:"
    git status -s
    
    # Show commits ahead/behind
    echo ""
    echo "Commits:"
    local ahead behind
    ahead=$(git rev-list --count @{u}..)
    behind=$(git rev-list --count ..@{u})
    
    if [[ "$ahead" -gt 0 ]]; then
        echo "  ðŸ“¤ $ahead commit(s) ahead of origin"
    fi
    if [[ "$behind" -gt 0 ]]; then
        echo "  ðŸ“¥ $behind commit(s) behind origin"
    fi
    if [[ "$ahead" -eq 0 && "$behind" -eq 0 ]]; then
        echo "  âœ“ In sync with origin"
    fi
}

# GIT LOG - Show recent commits
git_log() {
    local limit="${1:-10}"
    
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not a git repository"
        return 1
    fi
    
    echo "Recent commits:"
    git log --oneline -n "$limit"
}

# Check dependencies
check_dependencies() {
    local missing=()
    
    command -v gh >/dev/null 2>&1 || missing+=("gh (GitHub CLI)")
    command -v jq >/dev/null 2>&1 || missing+=("jq")
    command -v git >/dev/null 2>&1 || missing+=("git")
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required dependencies:"
        for dep in "${missing[@]}"; do
            log_error "  - $dep"
        done
        return 1
    fi
}

# Main function
main() {
    local command="${1:-}"
    
    # Handle global options before command
    if [[ -z "$command" ]]; then
        show_help
        exit 0
    fi
    
    case "$command" in
        --help|-h)
            show_help
            exit 0
            ;;
        --version)
            show_version
            exit 0
            ;;
        jump)
            shift
            cmd_jump "$@"
            exit $?
            ;;
        branch)
            shift
            cmd_branch "$@"
            exit $?
            ;;
        push)
            shift
            check_dependencies || exit 1
            git_push "$@"
            exit $?
            ;;
        pull)
            shift
            check_dependencies || exit 1
            git_pull "$@"
            exit $?
            ;;
        sync)
            shift
            check_dependencies || exit 1
            git_sync
            exit $?
            ;;
        status)
            shift
            check_dependencies || exit 1
            git_status
            exit $?
            ;;
        log)
            shift
            check_dependencies || exit 1
            git_log "$@"
            exit $?
            ;;
        *)
            log_error "Unknown command: $command"
            show_help
            exit 1
            ;;
    esac
}

# JUMP command handler
cmd_jump() {
    # Parse arguments
    local query=""
    local open_browser=0
    local do_checkout=0
    local search_type=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --open)
                open_browser=1
                shift
                ;;
            --checkout)
                do_checkout=1
                shift
                ;;
            --type)
                search_type="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            --help|-h)
                cat <<EOF
ghx jump - Search and jump to PRs, issues, branches, commits

USAGE
    ghx jump <query> [OPTIONS]

OPTIONS
    --open              Open the match in your browser
    --checkout          Checkout the matched PR/branch locally
    --type <type>       Limit search to type: pr, issue, branch, commit
    --verbose (-v)      Show debug output
    --help              Show help

EXAMPLES
    ghx jump OPS-123
    ghx jump "increase timeout" --open
    ghx jump OPS-123 --checkout
    ghx jump OPS-123 --type pr

SEARCH ORDER
    1. Pull Requests
    2. Issues
    3. Branches
    4. Commits

EOF
                exit 0
                ;;
            -*)
                log_error "Unknown option: $1"
                exit 1
                ;;
            *)
                if [[ -z "$query" ]]; then
                    query="$1"
                else
                    log_error "Unexpected argument: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$query" ]]; then
        log_error "Query is required"
        exit 1
    fi
    
    # Check dependencies
    if ! check_dependencies; then
        exit 1
    fi
    
    # Get repo info
    if ! repo=$(get_repo_info); then
        exit 1
    fi
    
    log_verbose "Using repository: $repo"
    
    # Search
    local result found_type
    if ! read -r result found_type < <(search_all "$repo" "$query" "$search_type"); then
        exit 1
    fi
    
    # Extract and display info
    local number title url branch_name
    read -r number title url branch_name found_type < <(extract_info "$result" "$found_type")
    
    print_result "$number" "$title" "$url" "$branch_name" "$found_type"
    
    # Handle --open flag
    if [[ $open_browser -eq 1 ]]; then
        open_url "$url" || exit 1
    fi
    
    # Handle --checkout flag
    if [[ $do_checkout -eq 1 ]]; then
        checkout_branch "$branch_name" "$found_type" || exit 1
        log_info "Successfully checked out: $branch_name"
    fi
}

# BRANCH command handler
cmd_branch() {
    local subcommand="${1:-}"
    
    check_dependencies || exit 1
    
    case "$subcommand" in
        list)
            list_branches
            ;;
        current)
            get_current_branch
            ;;
        switch)
            shift
            switch_branch "$@"
            ;;
        delete)
            shift
            delete_branch "$@"
            ;;
        create)
            shift
            create_branch "$@"
            ;;
        "")
            # No subcommand - show current branch
            local current
            if current=$(get_current_branch); then
                echo "Current branch: $current"
            fi
            ;;
        --help|-h)
            cat <<EOF
ghx branch - Manage git branches

USAGE
    ghx branch                  Show current branch
    ghx branch list             List all branches
    ghx branch current          Show current branch name
    ghx branch switch <name>    Switch to a branch
    ghx branch delete <name>    Delete a branch
    ghx branch create <name>    Create a new branch

EXAMPLES
    ghx branch list
    ghx branch switch main
    ghx branch switch feature/
    ghx branch create feature/new-feature
    ghx branch delete old-feature

NOTES
    - 'switch' supports fuzzy matching for branch names
    - 'switch' will use fzf if available for interactive selection
    - 'delete' requires confirmation

EOF
            ;;
        *)
            log_error "Unknown branch subcommand: $subcommand"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
